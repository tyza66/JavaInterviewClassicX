# GC如何让判断对象可以被回收
- 引用计数法：每个对象有一个引用计数属性，新增一个引用的时候技术就会加一，释放一个引用的时候计数就会减一，任何时刻计数为零的对象就是不可能再被使用的，就可以被回收了
- 可达性算法：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的时候，则证明此对象是不可用的，那么虚拟机可以判断这个对象可回收
- GC Root对象：虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区中静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI（Native方法）引用的对象
- 可达性算法中的不可达对象不是立即死亡的，不可达的对象有一次自我拯救的机会。对象被系统宣告死亡至少要经历两次标记的过程：第一次是经过可达性分析发现没有与GC Root相连接的引用链、第二次是在进行筛选的时候，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为可以回收
- 当对象没断定为GC Roots不可达之后，GC会先判断对象是否覆盖finalize方法，没覆盖或者已经执行过了就可以回收，否则将其放入F-Queue队列中，由一低优先级的Finalizer线程去执行，执行该对象finalize方法，如果对象在finalize方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时将会被移出“即将回收”的集合（复活），否则就会被回收
- finalize方法只会被执行一次，如果对象面临下一次回收，finalize方法不会被再次执行
- 由于finalize()方法运行价值高昂，不确定性大，无法保证各个对象的调用顺序