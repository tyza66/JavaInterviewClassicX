# sleep、wait、join、yield之间的区别
- 锁池：所有需要竞争同步锁的线程都会放在锁池中，比如当前对象的锁已经被其中一个线程得到，则其他线程需要在这个锁池中等待，当前面的线程释放掉同步锁之后，锁池中的线程会去竞争同步锁，当某个线程得到后就会进入就绪队列等待cup的资源分配。
- 等待池：当我们调用了wait方法之后，线程会放到等待池中，等待池的线程不会去竞争同步锁。只有调用了notify或者notfyAll后等待池中的线程才会开始去竞争锁，notify是随机从等待池选出一个线程放到锁池，而notifyAll则是把等待池中的所有线程都放到锁池中去竞争同步锁。
- sleep是Thread类的静态本地方法，wait方法是Object类的本地方法
- sleep方法不会释放锁，wait方法会释放锁
- sleep就是把cpu的执行权释放出去，不再运行这个线程，当定时时间结束再取回cpu资源，参与cpu的调度，获取到cpu资源后就可以继续运行了，而如果sleep时该线程有锁，这个锁不会被释放，而是带着锁进入了冻结状态，也就是说其他需要这个锁的线程根本不可能获取这个锁，也就是说无法执行程序，如果在睡眠期间其他线程调用了这个锁的interrupt方法，那么这个线程也会抛出InterruptedException异常而返回，这点wait方法是一样的
- sleep方法不依赖于同步器synchronized，而wait方法依赖于同步器synchronized
- sleep不需要被唤醒，但是wait方法需要被唤醒
- sleep方法一般用于当前线程休眠，或者轮询暂停操作，wait则多用于多线程之间的通信
- sleep方法会让出cpu执行时间片并且强制切换上下文，而wait不一定，wait后可能还是有机会重新竞争到锁继续执行
- yieid执行后线程直接进入就绪状态，马上释放了cpu的执行权，但是依旧保留了cpu的执行资格，所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行
- 其他线程的join方法在本线程中执行后本线程进入阻塞状态，例如在线程B中调用线程A的join方法，那么线程B会进入到阻塞队列，直到线程A结束或或者中断执行。