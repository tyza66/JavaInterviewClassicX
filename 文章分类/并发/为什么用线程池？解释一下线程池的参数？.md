# 为什么用线程池？解释一下线程池参数？
## 为什么用线程池？
    - 降低资源消耗，提高线程利用率，降低创建和销毁线程的消耗
    - 提高响应速度，任务到达时，无需等待线程创建即可立即执行
    - 提高线程的客观理性，使用线程池可以统一分配调优监控
## 线程池的参数
- corePoolSize：核心线程数，就是正常情况下创建工作的线程数，这些线程创建后并不会消除，而是一种常驻的线程
- maxinumPoolSize：最大线程数，它与核心线程数相对应，表示最大被允许创建的线程数，比如当前任务比较多，将核心线程数都用完了，还无法满足需求，这时候就会创建新的线程，但是线程池中的总线程数不会超过最大线程数
- keepAliveTime、unit：表示超出核心线程数以外的线程的空闲存活时间，也就是核心线程不会消除，但是超出核心线程数的部分线程如果空闲一定的时间则会被消除，我们可以通过setKeepAliveTime来设置空闲时间
- workQueue:工作队列，用于存放提交的等待执行的任务，这个队列是一个阻塞队列，当核心线程数都被占用时，新的任务会被放在队列中等待执行，直到整个队列被放满但任务还在持续进入则会开始创建新的线程
- ThreadFactory：实际上是一个线程工厂，用来生产线程执行任务。我们可以选择使用默认的创建工厂，产生的线程都是同一个组内，拥有相同的优先级，并且都不是守护线程，当然我们也可以选择自定义线程工厂，一般我们会根据业务来制定不同的线程工厂
- Handler：任务拒绝策略，有两种情况，第一种当我们调用shutdown等方法关闭线程池后，这时候即使线程池内部还有没执行完的任务正在执行，但是由于线程池已经关闭，我们再继续向向线程池提交任务就会遭到拒绝。另一种情况是当达到最大线程数的时候，线程池已经没有能力继续处理提交任务的时候，也会拒绝。我们可以通过Handler来制定拒绝策略，有四种策略：
    - AbortPolicy：直接抛出异常
    - CallerRunsPolicy：只用调用者所在线程来运行任务
    - DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务
    - DiscardPolicy：不处理，丢弃掉