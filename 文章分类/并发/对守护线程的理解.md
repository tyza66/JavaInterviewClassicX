# 对守护线程的理解
- 线程守护就是为所有非守护线程提供服务的线程，任何一个守护线程都是整个JVM中所有非守护线程的保姆，只要当前JVM实例中尚存任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程才随着JVM一同结束工作。
- 守护线程的终止是自身无法控制的，所以不要把IO和文件等操作逻辑分配给它
- GC就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread，程序就不会再产生垃圾，垃圾回收机制也没什么做的事情，所以当垃圾回收线程是JVM上仅剩的线程的时候，垃圾回收线程就会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源
- thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。
- 在Daemon线程中产生的新线程也是Daemon的
- 守护线程不能用于去访问固有资源，比如读写或者计算逻辑，因为他会在任何时候或者任何操作的时候中断
- Java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以如果要使用后台线程就不能用java的线程池