1.
	是一个团队，或者一个组织制定的一套固定的语法规则.
	你可以学习这套语法规则，然后通过这套语法规则和计算机进行交互.

2.
	高级语言完全接近人类自然语言，Java语言：完全面向对象（java语言底层实际上是C++实现的。）
	java是堪称完全面向对象的。
	面向对象更容易让人理解，人类通常是以对象的方式认知世界的。
	采用面向对象的方式可以让复杂问题简单化。

3.
	1、JAVA被分为三大块
	 J2SE    标准版（基础，要学java，必须先学习SE。基础语法+基础库）
	 J2EE    企业版（专门为企业开发软件，为企业提供解决方案。列如：OA办公系统，保险行特的系统，金融行业的系统，医院系统。）
	 J2ME   微型版   （专门为卫星设备做嵌入式开发的。）
       1.2、java诞生十周年改了名字
	 javaSE
	 javaEE
 	 javaME

4.
	JDK：  java开发工具箱
	JRE：   java运行环境
	JVM： java虚拟机

5.
	可移植性/跨平台 
	java语言只要编写一次，可以做到到处运行。
	例如：java程序编写完之后，可以运行在windows操作系统上，不需要做任何改动可以直接运行在Linnux操作系统上，同样也可以运行到Mac OS 上面。
	一次编写，到处运行。（平台改变了，程序不需要改。）
             JVM这种机制实现了跨平台，那么这种机制优点和缺点分别是什么？
	优点：一次编写到处运行，可以跨平台。
	缺点：麻烦。对于运行java程序来说必须先有一个JVM。
	就像你要想在网页上看视频，必须先安装一个Flash是一样的。

6.
	健壮性
	主要是因为Java中有一种机制：自动垃圾回收机制（GC机制）
	java语言是健壮的，相对于C语言来说，C语言没有JAVA健壮。
	java不容易导致内存的泄露.C++或者C语言使用不当时很容易导致内存泄漏.
                JVM负责调度GC机制，程序员不需要干涉。
              以上讲解中有描述了这几个术语： 
	JVM（C++语言写的一个虚拟的计算机）GC（垃圾回收机制）

	java完全/完美支持多线程开发。

7.
	java程序员直接编写的java代码（普通文本）是无法执行被JVM识别的
	      java程序员编写的java代码这种普通文本必须经过一个编译，将这个"普通文本"代码"变成""字节码”JVM能够识别"字节码"
     	java代码这种普通文本变成字节码的过程，被称为：编译
	java代码这种普通文本被称为：java源代码。（你编写的代码是源代码）
	源代码不能直接执行，需要先进行编译，生成源代码对应的“字节码”
    	JVM可以识别的是字节码
       放源代码的文件扩展名必须是：xxx.java
       并且需要注意的是：编译生成的字节码文件扩展名是：xxx.class
	.java文件就是源文件，这个文件中编写源代码。
	.class文件就是字节码文件，这个文件是编译源代码而得到的。

8.
	C++语言：一半面向过程，一半面向对象
	Java语言：完全面向对象（java语言底层实际上是C++实现的。）

9.	第一种：基本数据类型
		基本数据类型又可以划分为4大类8小种：
			第一类：整数型
				byte,short,int,long （没有小数的）
			第二类：浮点型 
				float,double （带有小数的）
			第三类：布尔型
				boolean：只有两个值true和false，true表示真，false表示假
			第四类：字符型
				char：java中规定字符型字面量必须使用单引号括起来。属于文字
		8小种：
			byte,short,int,long
			float,double
			boolean
			char
10.
	switch可作用于char byte short int
	switch可作用于char byte short int对应的包装类
	switch不可作用于long double float boolean，包括他们的包装类

11.
	2<<

12.	
	Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。

所谓向上取整指当计算的结果不为整数时取大于计算结果的整数,向下取整指当计算的结果不为整数时取小于计算结果的整数.当计算结果为整数时直接取整数

13.
	不正确

14.
	答：对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。


15.
	Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。

16.
	单行注释：
格式： // 注释文字多行注释：
格式： /* 注释文字 /
文档注释：
格式：/* 注释文字 */

17.
	private

		私有的，只对本类公开。

	default

		类的成员不写访问修饰符时默认为default，默认对于同一个包中的其它类相当于公开(public)，对于不是同一个包中的其它类相当于私有(private)。

	protected

		受保护(protected)，对同一个包中的其他类和子类相当于公开，对于不是同一个包且没有父子关系的相当于私有。

	public

		对所有类都是公开的。

18.
	&      逻辑 与 (可以翻译成并且)
	&&     短路与
	短路与&&的逻辑 与 &有什么区别?
	      		首先这两个运算符的运算结果没有任何区别，完全相同。
	      		只不过"短路与&&”会发生短路现象。
		什么是短路现象呢?
			右边表达式不执行，这种现象叫做短路现象。
	什么时候使用&&，什么时候使用& ?
		从效率方面来说，&&比&的效率高一些。
		因为逻辑与&不管第一个表达式结果是什么，第二个表达式一定会执行。
	
		以后的开发中，短路与&和逻辑与还是需要同时并存的。
		大部分情况下都建议使用短路与   &&
		只有当既需要左边表达式执行，又需要右边表达式执行的时候才会选择逻辑与&.

19.
	没有,java 保留了c中goto的理论,但是换了种形式,java中用带标签的continue,break来实现...

20.
	final关键字：
	1、final是java语言中的一个关键字。
	2、final表示最终的，不可变的。
	3、final修饰的变量只能赋一次值，一旦赋值不能重新赋值。（重点）
	4、final修饰的方法无法被覆盖，被重写。		         （重点）
	5、final修饰的类无法继承。			         （重点）		
	6、final控制不了能不能调用的问题，final修饰的表示最后的，不能变的，不能改的。 （提示）
	7、final修饰的引用，该引用只能指向1个对象，并且它只能永远指向该对象，
	     并且在该方法执行过程中，该引用指向该对象之后，该对象不会被垃圾回收器回收
	     final的引用指向对象A后，不能再重新指向对象B，但是对象A内部的数据可以被修改。

		结论: final修饰的实例变量，系统不负责赋默认值，要求程序员必须手动赋值。		
		        final修饰的实例变量一般添加static修饰。

		终极结论:final修饰的实例变量一般和static联合使用，称为常量。
	   	              常量名建议全部大写，每个单词之间采用下划线衔接。

			常量:实际上常量和静态变量一样,区别在于常量的值不能变。
			       常量和静态变量，都是存储在方法区，并且都是在类加载时初始化。
  				（常量的单词都是大写，单词之间用下滑线连接）
			       常量一般都是公共的: public的 。

				重点: final修饰的变量，只能赋一次值. 
21.
	this关键字:
	1、this是一个关键字，全部小写。
	2、 一个对象一个this.this是一个关键字、是一个变量，是一个引用。this保存当前对象的内存地址，指向自身。
	       所以，严格意义上来说，this代表的就是"当前对象”this存储在堆内存当中对象的内部。
	3、this 只能使用在实例方法中，也可以用在构造方法中，谁调用这个实例方法，this就是谁。所以this代表的是:当前对象。
	4、this.  大部分情况下是可以省略的。但是用来区分局部变量和实例变量的时候，不能省略。
	5、this不能使用在静态方法中，this代表当前对象，静态方法中不存在当前对象。
	6、this() 这种语法只能出现在构造方法第一行，表示当前构造方法调用本类其他的构造方法，目的是代码复用。
	7、新语法:通过当前的构造方法去调用另一个本类的构造方法可以使用以下语法格式:this (实际参数列表) ;

	程序再怎么变化，万变不离其宗，有一个固定的规律:		
		所有的实例相关的都是先创建(new)对象，通过"引用."来访问
		所有的静态相关的都是直接采用“类名."来访问.

	大结论:（一个类可以，跨类不可以）
		只要负责调用的方法a和被调用的方法b在同一个类当中:
			this.可以省略
			类名.可以省略

		但是如果跨类的情况下:
			this.不可以省略
			类名.不可以省略

22.super关键字：
	1、super是一个关键字，全部小写。
	2、super和this对比着学习.
		         this:
			this能出现在实例方法和构造方法中。
			this的语法是: "this."    "this()"
			this不能使用在静态方法中。
			this.大部分情况下是可以省略的。
			this.什么时候不能省略呢?在区分局部变量和实例变量的时候不能省略
				public void setName (String name) {
				         this.name = name ;
		this()只能出现在构造方法第一行，通过当前的构造方法去调用"本类"中其它的构造方法，目的是:代码复用。

	 	     super:
			super能出现在实例方法和构造方法中。
			super的语法是:"super." "super()"
			super不能使用在静态方法中。
			super.大部分情况下是可以省略的。
			super.什么时候不能省略呢?
				父类和子类中有同名属性，或者说有同样的方法，
				想在子类中访问父类的，super. 不能省略。
			super() 只能出现在构造方法第一行，通过当前的构造方法去调用"父类"中的构造方法	
			            目的是：创建子类对象的时候，先初始化父类型特征。

	3、super ()
		表示通过子类的构造方法调用父类的构造方法。模拟现实世界中的这种场景:要想有儿子，需要先有父亲。

	4、重要的结论:
		当一个构造方法第一行:
			既没有this()又没有super()的话，默认会有一个super() ;
			表示通过当前子类的构造方法调用父类的无参数构造方法。
			所以必须保证父类的无参数构造方法是存在的。

23.
	注意:this()和super()不能共存，它们都是只能出现在构造方法第一行。

	6、无论是怎样折腾，父类的构造方法是一定会执行的。(百分百的）
	
		在java语言中不管是new什么对象，最后老祖宗的object类的无参数构造方法一定会执行。
			(object类的无参数构造方法一定是处于"栈顶部")

			栈顶的特点:最后调用，但是最先执行结束。后进先出原则。

		
		1、"this."和"super."大部分情况下都是可以省略的。
		2、this.什么时候不能省略? 
	 	      想访问当前对象的属性的时候不能省。
		3、super.什么时候不能省略?
		      父中有，子中又有，如果想在子中访问“父的特征”，super.不能省略。

	java是怎么来区分子类和父类的同名属性的?
		this.name:当前对象的name属性
		super.name:当前对象的父类型特征中的name属性。
			总结：在父和子中有同名的属性，或者说有相同的方法，
			          如果此时想在子类中访问父中的数据，必须使用"super."加以区分。

	super的使用：
		super.属性名		【访问父类的属性】
		super.方法名(实参)		【访问父类的方法】
		super(实参)		【调用父类的构造方法】

24.25.26
	static关键字:	
	  1、static翻译为"静态"
	  2、所有static关键字修饰的都是类相关的，类级别的。
	  3、所有static修饰的，都是采用"类名 . "的方式访问。
	  4、static修饰的变量:   静态变量
	  5、static修饰的方法:   静态方法

	变量的分类:
	      变量根据声明的位置进行划分:
		     在方法体中声明的变量叫做:局部变量。
	     	     在方法体外声明的变量叫做:成员变量。（实例变量）
	       成员变量又可以分为:
		     	实例变量
	     	    	静态变量

	 什么时候变量声明为实例的，什么时候声明为静态的?
		如果这个类型的所有对象的某个属性值都是一样的，
			不建议定义为实例变量，浪费内存空间。建议定义为类级别特征，定义为静态变量，
			在方法区中只保留一份，节省内存开销.

		注意：一个对象一份的是实例变量，所有对象一份的是静态变量。

	实例变量:一定需要使用"引用."来访问。
	静态变量:建议使用"类名. "来访问，但使用"引用."也行(不建议使用"引用.")。
	              静态的如果使用"引用."来访问会让程序员产生困惑: 程序员以为是实例的呢。

	结论:空指针异常只有在什么情况下才会发生呢?
		只有在"空引用"访问"实例"相关的，都会出现空指针异常。

	 关于方法来说，什么时候定义为实例方法?什么时候定义为静态方法?有没有参考标准:
		此方法一般都是描述了一个行为，如果说该行为必须由对象去触发。那么该方法定义为实例方法。
	参考标准:
		当这个方法体当中，直接访问了实例变量，这个方法一定是实例方法。

		我们以后开发中，大部分情况下，如果是工具类的话，工具类当中的方法一般都是静态的。
		     静态方法有一个优点，是不需要new对象，直接采用类名.调用，极其方便。
		     工具类就是为了方便，所以工具类中的方法一般都是static的。


		类=属性+方法 
			属性描述的是:状态
			方法描述的是:行为动作
				一个方法代表了一个动作。

	静态代码块:
		1、使用static关键字可以定义:静态代码块
		2、什么是静态代码块，语法是什么?
				类{
				        //静态代码块
				     static{
				          java 语句;
				         }
				    }		
		3、static静态代码块在什么时候执行呢?
		      静态代码在类加载时执行。并且只执行一次。
		4、注意:静态代码块在类加载时执行，并且在main方法执行之前执行。
		5、静态代码块一般是按照自上而下的顺序执行。
		6、静态代码块有啥作用，有什么用?

	看具体的业务:
		项目经理说了:大家注意了，所有我们编写的程序中，
		只要是类加载了，请记录一下类加载的日志信息(在哪年哪月哪日几时几分几秒，哪个类加载到JVM当中了)。
	注意：:这些记录日志的代码写到静态代码块当中。
		
	    总结:
		到目前为止，你遇到的所有java程序，有顺序要求的是哪些?
			第一:对于一个方法来说，方法体中的代码是有顺序的，遵循自上而下的顺序执行.
			第二:静态代码块1和静态代码块2是有先后顺序的。
			第三:静态代码块和静态变量是有先后顺序的。

		1、除了静态代码块之外，还有一种语句块叫做:实例语句块
		2、实例语句在类加载时并没有执行.
		3、实例语句语法?
			java语句;
			java语句;
			java语句;
		4、实例语句块在什么时候执行?
	只要是构造方法执行，必然在构造方法执行之前，自动执行"实例语句块"中的代码.
	实际上这也是SUN公司为java程序员准备一个特殊的时机，叫做对象构建时机。


27.28关于转向语句：
	         break;语句:
		1、break;语句比较特殊，特殊在: break语句是一个单词成为一个完整的java语句。
			另外: continue也是这样， 他俩都是一个单词成为一条语句.
		2、break;翻译为折断、弄断。
		3、break;语句可以用在哪里呢?
	用在两个地方，其它位置不行
		第一个位置: switch语句当中， 用来终止switch语句的执行，防止case穿透现象，用来终止switch.
		第二个位置: break; 语句用在循环语句当中，用来终止循环的执行。
			  用在for当中
			  用在while当中
			  用在do...while当中。

		4、以下程序主要是以for循环为例学习break转向语句.
		5、break; 语句的执行并不会让整个方法结束，break;语句主要是用来终止离它最近的那个循环语句。
		6、怎么用break;语句终止指定的循环呢?
		      创建一个for循环  例如:
				for(int i=0;i<10;i++){
				        if(i==5){break;}
				System.out....（i）	
				}
			直接终止这个for循环：JAVA中的就近原则。
	    continue;语句:
		1、continue;翻译为:继续
		2、continue;语句和break语句要对比着学习
		3、continue;语句的作用是:
			终止当前"本次"循环，直接进入下一次循环继续执行。
				for(int i=0;i<10;i++){
				        if(i==5）{continue;}
				System.out....（i）	
				}
			当这个continue语句执行时，直接跳过5下面的代码不执行，直接进入下一次循环执行。
		4、conitinue语句后面可以指定循环吗?  可以的！
				a:for(; ;更新表达式1) {
				b:for(; ;更新表达式2) {
					if() {
					continue a;
					}
		可以给循环起名字，列如：
				a:for(){}   名字叫a
				b:for(){}   名字叫b	






















































	























































       1.5、java完全/完美支持多线程开发。
       1.6、可移植性/跨平台 